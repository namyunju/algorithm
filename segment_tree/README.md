## 세그먼트 트리

point update와 range query를 모두 O(logN)의 시간에 처리할 수 있는 자료구조

- 시간/공간 복잡도가 효율적
- 구현 짧음
- 다양한 변형이 가능


### 기초적 형태

교환법칙이 성립하는 연산에 대한 range query를 처리하는 segment tree

- 예시

5, -1, 3, 2, -8 수열의 구간 합 구하기

1. 완전 탐색

- 특정 인덱스 값 교체 (point update)
    - arr[i] = x 방식, O(1) 

- i번째부터 j번째까지 구간 합 (range query)
    - result += arr[i] 방식으로 모두 더해야 함, O(N)

2. DP 사용

- 미리 O(N^2)개의 구간 합을 계산하고 시작

| $dp_{l,r}$ | $r = 0$ | $r = 1$ | $r = 2$ | $r = 3$ | $r = 4$ | $r = 5$ |
| :--- | :---: | :---: | :---: | :---: | :---: | :---: |
| **$l = 0$** | 0 | 5 | 4 | 7 | 9 | 1 |
| **$l = 1$** | ❌ | 0 | -1 | 2 | 4 | -4 |
| **$l = 2$** | ❌ | ❌ | 0 | 3 | 5 | -3 |
| **$l = 3$** | ❌ | ❌ | ❌ | 0 | 2 | -6 |
| **$l = 4$** | ❌ | ❌ | ❌ | ❌ | 0 | -8 |

- 쿼리를 O(1)에 구할 수 있음
- but 수열 값 하나 바뀐다면 그 값 포함하는 모든 구간 합이 바뀌게 됨. O(N^2)개의 값 갱신
- point update O(N^2)
- range query O(1)

